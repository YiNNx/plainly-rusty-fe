import React from 'react';
import { useParams } from 'react-router-dom';
import PostDetail from '../components/Post/Detail';
import PostComment from './Comment';
import { PostContainer } from '../containers/Cantainers';

const Post: React.FC = () => {
  const { id } = useParams(); 

  const post = {
    id: '1',
    title: '这是一篇博客',
    // content: '\n\n这是一级标题这是一级标题是一级标题这是一级标题\n\n## h2 Heading\n\n这是标题这是标题这是标题这是标题这是标题这是标题\n\n### h3 Heading\n\n这是标题这是标题这是标题这是标题这是标题这是标题这是标题这是标题这是标题这是标题这是标题这是标题这是标题这是标题\n\n---\n\n**This is bold text**\n\n*This is italic text*\n\n> Blockquotes\n\n## List\n\nUnordered\n\n- Very easy!\n  - Yeah\n\nOrdered\n\n1. Lorem ipsum dolor sit amet\n2. Consectetur adipiscing elit\n\n\n## Code\n\nInline `code`\n\n``` js\nvar foo = function (bar) {\n  return bar++;\n};\n\nconsole.log(foo(5));\n```\n\n## Tables\n\n| Test | Test |\n| ---- | ---- |\n| test | test |\n\n\n## Links\n\n[link text](http://dev.nodeca.com)\n\n## Images\n\n![Stormtroopocat](https://octodex.github.com/images/stormtroopocat.jpg)\n\n',
    content: '## 光速上手\n\n```shell\ncargo new world_hello\ncargo run\ncargo build\ncargo check\n```\n\n在 `Cargo.toml` 中，主要通过各种依赖段落来描述该项目的各种依赖项：\n\n- 基于 Rust 官方仓库 `crates.io`，通过版本说明来描述\n- 基于项目源代码的 git 仓库地址，通过 URL 来描述\n- 基于本地项目的绝对路径或者相对路径，通过类 Unix 模式的路径来描述\n\n```toml\n[dependencies]\nrand = \"0.3\"\nhammer = { version = \"0.5.0\"}\ncolor = { git = \"https://github.com/bjz/color-rs\" }\ngeometry = { path = \"crates/geometry\" }\n```\n\n### 项目结构\n\n- **Package**：可以用来构建、测试和分享包\n- **WorkSpace**：对于大型项目，可以进一步将多个包联合在一起，组织成工作空间\n- **Crate**：一个由多个模块组成的树形结构，可以作为三方库进行分发，也可以生成可执行文件进行运行\n- **Module**：可以一个文件多个模块，也可以一个文件一个模块，模块可以被认为是真实项目中的代码组织单元\n\n```shell\n.\n├── Cargo.toml\n├── Cargo.lock\n├── src\n│   ├── main.rs\n│   ├── lib.rs\n│   └── bin\n│       └── main1.rs\n│       └── main2.rs\n├── tests\n│   └── some_integration_tests.rs\n├── benches\n│   └── simple_bench.rs\n└── examples\n    └── simple_example.rs\n```\n\n## 你好世界\n\n```rust\nfn greet_world() {\n    let southern_germany = \"Grüß Gott!\";\n    let chinese = \"世界，你好\";\n    let english = \"World, hello\";\n    let regions = [southern_germany, chinese, english];\n    for region in regions.iter() {\n        println!(\"{}\", &region);\n    }\n}\n\nfn main() {\n    greet_world();\n}\n```\n\n- `!`宏操作符\n\n- `iter`迭代器\n\n```rust\nfn main() {\n   let penguin_data = \"\\n   common name,length (cm)\n   Little penguin,33\n   Yellow-eyed penguin,65\n   Fiordland penguin,60\n   Invalid,data\n   \";\n\n   let records = penguin_data.lines();\n\n   for (i, record) in records.enumerate() {\n     if i == 0 || record.trim().len() == 0 {\n       continue;\n     }\n\n     // 声明一个 fields 变量，类型是 Vec\n     // Vec 是 vector 的缩写，是一个可伸缩的集合类型，可以认为是一个动态数组\n     // <_>表示 Vec 中的元素类型由编译器自行推断，在很多场景下，都会帮我们省却不少功夫\n     let fields: Vec<_> = record\n       .split(\',\')\n       .map(|field| field.trim())\n       .collect();\n     if cfg!(debug_assertions) {\n         // 输出到标准错误输出\n       eprintln!(\"debug: {:?} -> {:?}\",\n              record, fields);\n     }\n\n     let name = fields[0];\n     // 1. 尝试把 fields[1] 的值转换为 f32 类型的浮点数，如果成功，则把 f32 值赋给 length 变量\n     //\n     // 2. if let 是一个匹配表达式，用来从=右边的结果中，匹配出 length 的值：\n     //   1）当=右边的表达式执行成功，则会返回一个 Ok(f32) 的类型，若失败，则会返回一个 Err(e) 类型，if let 的作用就是仅匹配 Ok 也就是成功的情况，如果是错误，就直接忽略\n     //   2）同时 if let 还会做一次解构匹配，通过 Ok(length) 去匹配右边的 Ok(f32)，最终把相应的 f32 值赋给 length\n     //\n     // 3. 当然你也可以忽略成功的情况，用 if let Err(e) = fields[1].parse::<f32>() {...}匹配出错误，然后打印出来，但是没啥卵用\n     if let Ok(length) = fields[1].parse::<f32>() {\n         // 输出到标准输出\n         println!(\"{}, {}cm\", name, length);\n     }\n   }\n }\n```\n\n## 来点\n\n### 基础语法\n\n- Rust 的函数体是由一系列语句组成，最后由一个表达式来返回值\n\n  ```rust\n  fn add_with_extra(x: i32, y: i32) -> i32 {\n      let x = x + 1; // 语句\n      let y = y + 5; // 语句\n      x + y // 表达式\n  }\n  ```\n\n- `let a = 30_i32;` -> const\n\n  `let mut b = 30_i32;` -> var\n\n  **类型转换必须是显式的**. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数\n\n- 使用下划线开头忽略未使用的变量\n\n| 条目                               | 惯例                                                         |\n  | ---------------------------------- | ------------------------------------------------------------ |\n  | 包 Crates                          | [unclear](https://github.com/rust-lang/api-guidelines/issues/29) |\n  | 模块 Modules                       | `snake_case`                                                 |\n  | 类型 Types                         | `UpperCamelCase`                                             |\n  | 特征 Traits                        | `UpperCamelCase`                                             |\n  | 枚举 Enumerations                  | `UpperCamelCase`                                             |\n  | 结构体 Structs                     | `UpperCamelCase`                                             |\n  | 函数 Functions                     | `snake_case`                                                 |\n  | 方法 Methods                       | `snake_case`                                                 |\n  | 通用构造器 General constructors    | `new` or `with_more_details`                                 |\n  | 转换构造器 Conversion constructors | `from_some_other_type`                                       |\n  | 宏 Macros                          | `snake_case!`                                                |\n  | 局部变量 Local variables           | `snake_case`                                                 |\n  | 静态类型 Statics                   | `SCREAMING_SNAKE_CASE`                                       |\n  | 常量 Constants                     | `SCREAMING_SNAKE_CASE`                                       |\n  | 类型参数 Type parameters           | `UpperCamelCase`，通常使用一个大写字母: `T`                  |\n  | 生命周期 Lifetimes                 | 通常使用小写字母: `\'a`，`\'de`，`\'src`                        |\n  | Features                           | [unclear](https://github.com/rust-lang/api-guidelines/issues/101) but see [C-FEATURE](https://course.rs/practice/naming.html#c-feature) |\n\n- ### `let`变量绑定 -> 所有权\n\n- 常量使用 `const` 关键字而不是 `let` 关键字来声明，并且值的类型**必须**标注。\n\n- ### 变量遮蔽（shadowing）\n\n  ```rust\n  fn main() {\n      let x = 5;\n      // 在main函数的作用域内对之前的x进行遮蔽\n      let x = x + 1;\n  \n      {\n          // 在当前的花括号作用域内，对之前的x进行遮蔽\n          let x = x * 2;\n          println!(\"The value of x in the inner scope is: {}\", x);\n      }\n  \n      println!(\"The value of x is: {}\", x);\n  }\n  ```\n\n- Range\n\n  ```rust\n  for i in 1..=5 {\n      println!(\"{}\",i);\n  }\n  ```\n\n  \n\n- 单元类型\n\n  单元类型就是 `()` ，唯一的值也是 `()` \n\n  `main` 函数就返回这个单元类型 `()`，常见的 `println!()` 的返回值也是单元类型 `()`。\n\n  再比如，你可以用 `()` 作为 `map` 的值，表示我们不关注具体的值，只关注 `key`。 这种用法和 Go 语言的 ***struct{}*** 类似，可以作为一个值用来占位，但是完全**不占用**任何内存。\n\n- 特殊返回值\n\n  - 无返回值`()`\n  - 永不返回的发散函数 !\n\n### 所有权\n\n在计算机语言不断演变过程中，出现了三种流派：\n\n- **垃圾回收机制(GC)**，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go\n- **手动管理内存的分配和释放**, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++\n- **通过所有权来管理内存**，编译器在编译时会根据一系列规则进行检查\n\n其中 Rust 选择了第三种，最妙的是，这种检查只发生在编译期，因此对于程序运行期，不会有任何性能上的损失。\n\n当变量离开作用域后，Rust 会自动调用 `drop` 函数并清理变量的堆内存。\n\n与其它系统编程语言的 `free` 函数相同，Rust 也提供了一个释放内存的函数： `drop`，但是不同的是，其它语言要手动调用 `free` 来释放每一个变量占用的内存，而 Rust 则在变量离开作用域时，自动调用 `drop` 函数: 上面代码中，Rust 在结尾的 `}` 处自动调用 `drop`。\n\n> 1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者\n> 2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者\n> 3. 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)\n\n当一个变量赋值另一个变量简单结构**（可Copy）**时，进行拷贝\n\n> 如下是一些 `Copy` 的类型：\n>\n> - 所有整数类型，比如 `u32`\n> - 布尔类型，`bool`，它的值是 `true` 和 `false`\n> - 所有浮点数类型，比如 `f64`\n> - 字符类型，`char`\n> - 元组，当且仅当其包含的类型也都是 `Copy` 的时候。比如，`(i32, i32)` 是 `Copy` 的，但 `(i32, String)` 就不是\n> - 不可变引用 `&T` ，例如[转移所有权](https://course.rs/basic/ownership/ownership.html#转移所有权)中的最后一个例子，但是注意: 可变引用 `&mut T` 是不可以 Copy的\n\n而对于复杂结构，则发生**移动**（浅拷贝+原变量失效）\n\n```rust\nlet s1 = String::from(\"hello\");\nlet s2 = s1;\n\nprintln!(\"{}, world!\", s1);\n```\n\n```shell\nerror[E0382]: use of moved value: `s1`\n --> src/main.rs:5:28\n  |\n3 |     let s2 = s1;\n  |         -- value moved here\n4 |\n5 |     println!(\"{}, world!\", s1);\n  |                            ^^ value used here after move\n  |\n  = note: move occurs because `s1` has type `std::string::String`, which does\n  not implement the `Copy` trait\n```\n\n**将值传递给函数，一样会发生 `移动` 或者 `复制`，就跟 `let` 语句一样**\n\n```rust\nfn main() {\n    let s = String::from(\"hello\"); \n    takes_ownership(s);\n    println!(\"s: {}\", s);\n    // ERROR: borrow of moved value: `s` value borrowed here after move\n}\nfn takes_ownership(some_string: String) {\n    println!(\"{}\", some_string);\n}\n```\n\n不报错做法 -> 传递不可变引用（借用）\n\n**clone**\n\n深拷贝需手动进行，即`.clone()`\n\n对性能有损耗\n\n### 可变引用\n\n引用和变量一样，也是默认不可变的。对于 mut 变量，使用可变引用`& mut`来改变引用的对象\n\n- **同一作用域，特定数据只能有一个可变引用**\n\n- **可变引用与不可变引用不能同时存在**\n\n  在新的编译器中，引用作用域的结束位置从花括号变成最后一次使用的位置\n\n> 这是为了使 Rust 在编译期就避免数据竞争：\n>\n> - 两个或更多的指针同时访问同一数据\n> - 至少有一个指针被用来写入数据\n> - 没有同步数据访问的机制\n\n### 悬垂引用(Dangling References)\n\n悬垂引用也叫做悬垂指针，意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。在 Rust 中编译器可以确保引用永远也不会变成悬垂状态。\n\n### 切片 Slice\n\n```rust\nlet s = String::from(\"hello world\");\n\nlet hello = &s[0..5];\nlet world = &s[6..11];\n```\n\n切片是不可用引用类型\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello world\");\n\n    let word = first_word(&s);\n\n    s.clear(); // error!\n\n    println!(\"the first word is: {}\", word);\n}\nfn first_word(s: &String) -> &str {\n    &s[..1]\n}\n```\n\n```shell\nerror[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable\n  --> src/main.rs:18:5\n   |\n16 |     let word = first_word(&s);\n   |                           -- immutable borrow occurs here\n17 |\n18 |     s.clear(); // error!\n   |     ^^^^^^^^^ mutable borrow occurs here\n19 |\n20 |     println!(\"the first word is: {}\", word);\n   |                                       ---- immutable borrow later used here\n```\n\n`String` cannot be indexed by `{integer}`\n\n不同语言的单字符长度可能为不同个char。从字符串中取字符通常不直接用切片。可以用[utf8_slice](https://crates.io/crates/utf8_slice)\n\n### 结构体\n\n默认所有字段都是私有的，只对当前文件公开\n\n公开 => pub \n\n```rust\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n```\n\n```rust\n    let user1 = User {\n        email: String::from(\"someone@example.com\"),\n        username: String::from(\"someusername123\"),\n        active: true,\n        sign_in_count: 1,\n    };\n```\n\n使用 #[derive(Debug)] 来打印结构体的信息\n\n需要注意的是，必须要将结构体实例声明为可变的，才能修改其中的字段，Rust 不支持将某个结构体某个字段标记为可变。\n\n```rust\nfn build_user(email: String, username: String) -> User {\n    User {\n        email,\n        username,\n        active: true,\n        sign_in_count: 1,\n    }\n}\n```\n\n```rust\n  let user2 = User {\n        email: String::from(\"another@example.com\"),\n        ..user1\n    };\n```\n\n**在上面代码中，`user1` 的`username` 字段发生了所有权转移，将无法再访问该字段（但可以正常访问其他字段）**\n\n好用的 debug 方法：\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let scale = 2;\n    let rect1 = Rectangle {\n        width: dbg!(30 * scale),\n        height: 50,\n    };\n\n    dbg!(&rect1);\n}\n```\n\n### 方法\n\n- `self` 表示 `Rectangle` 的所有权转移到该方法中，这种形式用的较少\n- `&self` 表示该方法对 `Rectangle` 的不可变借用\n- `&mut self` 表示可变借用\n- **关联函数** => 不带self\n- 使用 `new` 来作为构造器的名称\n- 枚举也可以实现方法\n\n### 枚举\n\n```rust\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    let m1 = Message::Quit;\n    let m2 = Message::Move{x:1,y:1};\n    let m3 = Message::ChangeColor(255,255,0);\n}\n```\n\n该枚举类型代表一条消息，它包含四个不同的成员：\n\n- `Quit` 没有任何关联数据\n- `Move` 包含一个匿名结构体\n- `Write` 包含一个 `String` 字符串\n- `ChangeColor` 包含三个 `i32`\n\n当然，我们也可以用结构体的方式来定义这些消息：\n\n```rust\nstruct QuitMessage; // 单元结构体\nstruct MoveMessage {\n    x: i32,\n    y: i32,\n}\nstruct WriteMessage(String); // 元组结构体\nstruct ChangeColorMessage(i32, i32, i32); // 元组结构体\n```\n\n由于每个结构体都有自己的类型，因此我们无法在需要同一类型的地方进行使用，例如某个函数它的功能是接受消息并进行发送，那么用枚举的方式，就可以接收不同的消息，但是用结构体，该函数无法接受 4 个不同的结构体作为参数。\n\n判断相等：`match`或`matches!()`\n\n### Option 枚举用于处理空值\n\n```rust\nenum Option<T> {\n    Some(T),\n    None,\n}\n```\n\n```rust\nfn plus_one(x: Option<i32>) -> Option<i32> {\n    match x {\n        None => None,\n        Some(i) => Some(i + 1),\n    }\n}\n\nlet five = Some(5);\nlet six = plus_one(five);\nlet none = plus_one(None);\n```\n\n解构 Option，模式绑定将其中的值绑定到`i`\n\n### 数组\n\n```rust\nlet a: [i32; 5] = [1, 2, 3, 4, 5];\nlet a = [3; 5];\nlet array: [String; 8] = std::array::from_fn(|_i| String::from(\"rust is good!\"));\n```\n\n数组访问越界将导致 Rust 运行时错误，而不是输出垃圾数据\n\n### 表达式\n\n#### if 表达式\n\n```rust\nfn main() {\n    let var1 = 10;\n\n    let var2 = if var1 >= 10 {\n        var1\n    } else {\n        var1 + 10\n    };\n\n    println!(\"{}\", var2);\n}\n```\n\n通过 `if` 表达式将值赋予 `var2`。用 `if` 来赋值时，要保证每个分支返回的类型一样\n\n你还可以在循环中结合 `continue` 、`break` 来使用：\n\n```rust\nlet mut v = 0;\nfor i in 1..10 {\n    v = if i == 9 {\n        continue\n    } else {\n        i\n    }\n}\nprintln!(\"{}\", v);\n```\n\n#### match 表达式\n\n```rust\nlet o = Some(3);\nlet v = match o {\n    Some(x) => x,\n    _ => 0\n};\n```\n\n#### if let 表达式\n\n有时会遇到只有一个模式的值需要被处理，其它值直接忽略的场景\n\n```rust\nlet o = Some(3);\nlet v = if let Some(x) = o {\n    x\n} else {\n    0\n};\n```\n\n#### loop 表达式\n\n```rust\nlet mut n = 0;\nlet v = loop {\n    if n == 10 {\n        break n\n    }\n    n += 1;\n};\n```\n\n#### 语句块\n\n```rust\nlet mut n = 0;\nlet v = {\n    println!(\"before: {}\", n);\n    n += 1;\n    println!(\"after: {}\", n);\n    n\n};\nprintln!(\"{}\", v);\n```\n\n### 流程控制\n\n使用 `for` 时我们往往使用集合的引用形式。如果不使用引用的话，所有权会被转移\n\n| 使用方法                      | 等价使用方式                                      | 所有权     |\n| ----------------------------- | ------------------------------------------------- | ---------- |\n| `for item in collection`      | `for item in IntoIterator::into_iter(collection)` | 转移所有权 |\n| `for item in &collection`     | `for item in collection.iter()`                   | 不可变借用 |\n| `for item in &mut collection` | `for item in collection.iter_mut()`               | 可变借用   |\n\n```rust\nfn main() {\n    let a = [4, 3, 2, 1];\n    // `.iter()` 方法把 `a` 数组变成一个迭代器\n    for (i, v) in a.iter().enumerate() {\n        println!(\"第{}个元素是{}\", i + 1, v);\n    }\n}\n```\n\n### 模式匹配\n\nlet match …\n\n- match\n\n```rust\nmatch target {\n    模式1 if ... => 表达式1,\n    模式1 => 表达式2,\n    模式2 | 模式3 => {\n        语句1;\n        语句2;\n        表达式3\n    },\n    1..=5 => 表达式4,\n    _ => 表达式5\n}\n```\n\n```rust\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(0, 160, 255);\n\n    match msg {\n        Message::Quit => {\n            println!(\"The Quit variant has no data to destructure.\")\n        }\n        Message::Move { x, y } => {\n            println!(\n                \"Move in the x direction {} and in the y direction {}\",\n                x,\n                y\n            );\n        }\n        Message::Write(text) => println!(\"Text message: {}\", text),\n        Message::ChangeColor(r, g, b) => {\n            println!(\n                \"Change the color to red {}, green {}, and blue {}\",\n                r,\n                g,\n                b\n            )\n        }\n    }\n}\n```\n\n- let (解构并分解值)\n\n```rust\n// Vec是动态数组\nlet mut stack = Vec::new();\n\n// 向数组尾部插入元素\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// stack.pop从数组尾部弹出元素\nwhile let Some(top) = stack.pop() {\n    println!(\"{}\", top);\n}\n```\n\n解构结构体\n\n```rust\nenum Color {\n   Rgb(i32, i32, i32),\n   Hsv(i32, i32, i32),\n}\n\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(Color),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));\n\n    match msg {\n        Message::ChangeColor(Color::Rgb(r, g, b)) => {\n            println!(\n                \"Change the color to red {}, green {}, and blue {}\",\n                r,\n                g,\n                b\n            )\n        }\n        Message::ChangeColor(Color::Hsv(h, s, v)) => {\n            println!(\n                \"Change the color to hue {}, saturation {}, and value {}\",\n                h,\n                s,\n                v\n            )\n        }\n        _ => ()\n    }\n}\n```\n\n### @ 绑定\n\n```rust\nenum Message {\n    Hello { id: i32 },\n}\n\nlet msg = Message::Hello { id: 5 };\n\nmatch msg {\n    Message::Hello { id: id_variable @ 3..=7 } => {\n        println!(\"Found an id in range: {}\", id_variable)\n    },\n    Message::Hello { id: 10..=12 } => {\n        println!(\"Found an id in another range\")\n    },\n    Message::Hello { id } => {\n        println!(\"Found some other id: {}\", id)\n    },\n}\n```\n\n### 泛型\n\n#### 枚举中使用泛型\n\n```rust\nenum Option<T> {\n    Some(T),\n    None,\n}\n```\n\n```rust\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n#### 方法中使用泛型\n\n```rust\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Point<T> {\n    fn x(&self) -> &T {\n        &self.x\n    }\n}\n\nfn main() {\n    let p = Point { x: 5, y: 10 };\n\n    println!(\"p.x = {}\", p.x());\n}\n```\n\n```rust\nfn add<T: std::ops::Add<Output = T>>(a:T, b:T) -> T {\n    a + b\n}\n```\n\n#### const 泛型\n\n```rust\nfn display_array<T: std::fmt::Debug, const N: usize>(arr: [T; N]) {\n    println!(\"{:?}\", arr);\n}\nfn main() {\n    let arr: [i32; 3] = [1, 2, 3];\n    display_array(arr);\n\n    let arr: [i32; 2] = [1, 2];\n    display_array(arr);\n}\n```\n\n### Rust 泛型的性能\n\n在 Rust 中泛型是零成本的抽象，意味着你在使用泛型时，完全不用担心性能上的问题。\n\n但是任何选择都是权衡得失的，既然我们获得了性能上的巨大优势，那么又失去了什么呢？Rust 是在编译期为泛型对应的多个类型，生成各自的代码，因此损失了编译速度和增大了最终生成文件的大小。\n\n具体来说：\n\nRust 通过在编译时进行泛型代码的 **单态化**(*monomorphization*)来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。\n\n编译器所做的工作正好与我们创建泛型函数的步骤相反，编译器寻找所有泛型代码被调用的位置并针对具体类型生成代码。\n\n### Trait (类似于interface)\n\n```rust\npub trait Summary {\n    fn summarize(&self) -> String;\n\n//  或定义一个默认实现\n//  fn summarize(&self) -> String {\n//      String::from(\"(Read more...)\")\n//  }\n}\n\npub struct Post {\n    pub title: String, // 标题\n    pub author: String, // 作者\n    pub content: String, // 内容\n}\n\nimpl Summary for Post {\n    fn summarize(&self) -> String {\n        format!(\"文章{}, 作者是{}\", self.title, self.author)\n    }\n}\n\npub fn notify(item: &impl Summary) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n```\n\n```rust\nfn some_function<T, U>(t: &T, u: &U) -> i32\n    where T: Display + Clone,\n          U: Clone + Debug\n{}\n```\n\n### 特征对象(*dynamic*)\n\n相当于interface实例\n\n```rust\ntrait Draw {\n    fn draw(&self) -> String;\n}\n\nimpl Draw for u8 {\n    fn draw(&self) -> String {\n        format!(\"u8: {}\", *self)\n    }\n}\n\nimpl Draw for f64 {\n    fn draw(&self) -> String {\n        format!(\"f64: {}\", *self)\n    }\n}\n\n// 若 T 实现了 Draw 特征， 则调用该函数时传入的 Box<T> 可以被隐式转换成函数参数签名中的 Box<dyn Draw>\nfn draw1(x: Box<dyn Draw>) {\n    // 由于实现了 Deref 特征，Box 智能指针会自动解引用为它所包裹的值，然后调用该值对应的类型上定义的 `draw` 方法\n    x.draw();\n}\n\nfn draw2(x: &dyn Draw) {\n    x.draw();\n}\n\nfn main() {\n    let x = 1.1f64;\n    // do_something(&x);\n    let y = 8u8;\n\n    // x 和 y 的类型 T 都实现了 `Draw` 特征，因为 Box<T> 可以在函数调用时隐式地被转换为特征对象 Box<dyn Draw> \n    // 基于 x 的值创建一个 Box<f64> 类型的智能指针，指针指向的数据被放置在了堆上\n    draw1(Box::new(x));\n    // 基于 y 的值创建一个 Box<u8> 类型的智能指针\n    draw1(Box::new(y));\n    draw2(&x);\n    draw2(&y);\n}\n```\n\n不是所有特征都能拥有特征对象，只有对象安全的特征才行。当一个特征的所有方法都有如下属性时，它的对象才是安全的：\n\n- 方法的返回类型不能是 `Self`\n- 方法没有任何泛型参数\n\n### 关联类型\n\n如果使用泛型，你将得到以下的代码：\n\n```rust\npub trait Iterator<Item> {\n    fn next(&mut self) -> Option<Item>;\n}\n```\n\n使用关联类型，将得到可读性好得多的代码：\n\n```rust\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n}\n```\n\n### 默认泛型类型参数\n\n```rust\ntrait Add<RHS=Self> {\n    type Output;\n\n    fn add(self, rhs: RHS) -> Self::Output;\n}\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -> Point {\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\nstruct Millimeters(u32);\nstruct Meters(u32);\n\nimpl Add<Meters> for Millimeters {\n    type Output = Millimeters;\n\n    fn add(self, other: Meters) -> Millimeters {\n        Millimeters(self.0 + (other.0 * 1000))\n    }\n}\n```\n\n### Vector\n\n```rust\nlet v = vec![1, 2, 3];\nlet mut v = Vec::new();\nv.push(1);\n```\n\n### HashMap\n\n```rust\nuse std::collections::HashMap;\n\n// 创建一个HashMap，用于存储宝石种类和对应的数量\nlet mut my_gems = HashMap::new();\n\n// 将宝石类型和对应的数量写入表中\nmy_gems.insert(\"红宝石\", 1);\nmy_gems.insert(\"蓝宝石\", 2);\nmy_gems.insert(\"河边捡的误以为是宝石的破石头\", 18);\n\n```\n\n```rust\nlet teams_list = vec![(\"中国队\", 100), (\"美国队\", 10), (\"日本队\", 50)];\nlet teams_map: HashMap<_, _> = teams_list.into_iter().collect();\n```\n\n### 错误处理\n\n```rust\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let f = File::open(\"hello.txt\");\n\n    let f = match f {\n        Ok(file) => file,\n        Err(error) => match error.kind() {\n            ErrorKind::NotFound => match File::create(\"hello.txt\") {\n                Ok(fc) => fc,\n                Err(e) => panic!(\"Problem creating the file: {:?}\", e),\n            },\n            other_error => panic!(\"Problem opening the file: {:?}\", other_error),\n        },\n    };\n}\n```\n\n```rust\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    // 打开文件，f是`Result<文件句柄,io::Error>`\n    let f = File::open(\"hello.txt\");\n\n    let mut f = match f {\n        // 打开文件成功，将file句柄赋值给f\n        Ok(file) => file,\n        // 打开文件失败，将错误返回(向上传播)\n        Err(e) => return Err(e),\n    };\n    // 创建动态字符串s\n    let mut s = String::new();\n    // 从f文件句柄读取数据并写入s中\n    match f.read_to_string(&mut s) {\n        // 读取成功，返回Ok封装的字符串\n        Ok(_) => Ok(s),\n        // 将错误向上传播\n        Err(e) => Err(e),\n    }\n}\n```\n\n#### 用`?`简化\n\n```rust\nuse std::fs::File;\nuse std::io;\nuse std::io::Read;\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    let mut s = String::new();\n\n    File::open(\"hello.txt\")?.read_to_string(&mut s)?;\n\n    Ok(s)\n}\n```\n\n这段代码和前面等价\n\n上面代码中 `File::open` 报错时返回的错误是 `std::io::Error` 类型，但是 `open_file` 函数返回的错误类型是 `std::error::Error` 的特征对象，可以看到一个错误类型通过 `?` 返回后，变成了另一个错误类型，这就是 `?` 的神奇之处。\n\n根本原因是在于标准库中定义的 `From` 特征，该特征有一个方法 `from`，用于把一个类型转成另外一个类型，`?` 可以自动调用该方法，然后进行隐式类型转换。因此只要函数返回的错误 `ReturnError` 实现了 `From<OtherError>` 特征，那么 `?` 就会自动把 `OtherError` 转换为 `ReturnError`。\n\n这种转换非常好用，意味着你可以用一个大而全的 `ReturnError` 来覆盖所有错误类型，只需要为各种子错误类型实现这种转换即可。\n\n## TIPS\n\n### immutable(default) & mutable\n\n### borrowed as immutable(default) & borrowed as mutable\n\n## 生命周期\n\n报错：编译时编译器无法确定返回值的生命周期\n\n```rust\nfn longest(x: &str, y: &str) -> &str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n```\n\n手动为编译器标注生命周期：表明返回值的生命周期为 x 和 y 中更短的那个\n\n```rust\nfn longest<\'a>(x: &\'a str, y: &\'a str) -> &\'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n```\n\n表明 str 活得必须比结构体久，否则就报错\n\n```rust\nstruct Test<\'a> {\n    part: &\'a str,\n}\n```\n\n\n\n### 三条消除规则\n\n编译器使用三条消除规则来确定哪些场景不需要显式地去标注生命周期。其中第一条规则应用在输入生命周期上，第二、三条应用在输出生命周期上。若编译器发现三条规则都不适用时，就会报错，提示你需要手动标注生命周期。\n\n1. **每一个引用参数都会获得独自的生命周期**\n\n   例如一个引用参数的函数就有一个生命周期标注: `fn foo<\'a>(x: &\'a i32)`，两个引用参数的有两个生命周期标注:`fn foo<\'a, \'b>(x: &\'a i32, y: &\'b i32)`, 依此类推。\n\n2. **若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期**，也就是所有返回值的生命周期都等于该输入生命周期\n\n   例如函数 `fn foo(x: &i32) -> &i32`，`x` 参数的生命周期会被自动赋给返回值 `&i32`，因此该函数等同于 `fn foo<\'a>(x: &\'a i32) -> &\'a i32`\n\n3. **若存在多个输入生命周期，且其中一个是 `&self` 或 `&mut self`，则 `&self` 的生命周期被赋给所有的输出生命周期**\n\n   拥有 `&self` 形式的参数，说明该函数是一个 `方法`，该规则让方法的使用便利度大幅提升。\n\n   若一个方法，它的返回值的生命周期就是跟参数 `&self` 的不一样，则手动标注生命周期\n\n## 函数式\n\n### 闭包\n\n闭包是**一种匿名函数，它可以赋值给变量也可以作为参数传递给其它函数，不同于函数的是，它允许捕获调用者作用域中的值**\n\n```rust\nfn main() {\n   let x = 1;\n   let sum = |y| x + y;\n\n    assert_eq!(3, sum(2));\n}\n```\n\n上面的代码展示了非常简单的闭包 `sum`，它拥有一个入参 `y`，同时捕获了作用域中的 `x` 的值，因此调用 `sum(2)` 意味着将 2（参数 `y`）跟 1（`x`）进行相加,最终返回它们的和：`3`。\n\n## 类型转换\n\n\n\n## NewType\n\n使用元组结构体的方式将已有的类型包裹起来\n\n- 自定义类型可以让我们给出更有意义和可读性的类型名，例如与其使用 `u32` 作为距离的单位类型，我们可以使用 `Meters`，它的可读性要好得多\n- 对于某些场景，只有 `newtype` 可以很好地解决\n- 隐藏内部类型的细节\n\n## DST\n\n编译器无法在编译期得知该类型值的大小，只有到了程序运行时，才能动态获知。因此，这些结构必须储存在堆上，通过栈上的值来引用。\n\nRust 中常见的 `DST` 类型有: `str`、`[T]`、`dyn Trait`，**它们都无法单独被使用，必须要通过引用或者 `Box` 来间接使用** 。\n\n```rust\nfn foobar_1(thing: &dyn MyThing) {}     // OK\nfn foobar_2(thing: Box<dyn MyThing>) {} // OK\nfn foobar_3(thing: MyThing) {}          // ERROR!\n```\n\n保证 `T` 是固定大小的类型？仔细回想下，貌似在之前的课程章节中，我们也没有做过任何事情去做相关的限制，那 `T` 怎么就成了固定大小的类型了？奥秘在于编译器自动帮我们加上了 `Sized` 特征约束：\n\n```rust\nfn generic<T: Sized>(t: T) {\n    // --snip--\n}\n```\n\n在上面，Rust 自动添加的特征约束 `T: Sized`，表示泛型函数只能用于一切实现了 `Sized` 特征的类型上，而**所有在编译时就能知道其大小的类型，都会自动实现 `Sized` 特征**，例如。。。。也没啥好例如的，你能想到的几乎所有类型都实现了 `Sized` 特征，除了上面那个坑坑的 `str`，哦，还有特征。\n\n**每一个特征都是一个可以通过名称来引用的动态大小类型**。因此如果想把特征作为具体的类型来传递给函数，你必须将其转换成一个特征对象：诸如 `&dyn Trait` 或者 `Box<dyn Trait>` (还有 `Rc<dyn Trait>`)这些引用类型。\n\n## 智能指针\n\n智能指针往往是基于结构体实现，它与我们自定义的结构体最大的区别在于它实现了 `Deref` 和 `Drop` 特征：\n\n- `Deref` 可以让智能指针像引用那样工作，这样你就可以写出同时支持智能指针和引用的代码，例如 `*T`\n- `Drop` 允许你指定智能指针超出作用域后自动执行的代码，例如做一些数据清除等收尾工作\n\n### `Box<T>`\n\n `Box<T>` 允许你将一个值分配到堆上，然后在栈上保留一个智能指针指向堆上的数据。\n\n可以在以下场景中使用它：\n\n- 特意的将数据分配在堆上\n- 数据较大时，又不想在转移所有权时进行数据拷贝\n- 类型的大小在编译期无法确定，但是我们又需要固定大小的类型时\n- 特征对象，用于说明对象实现了一个特征，而不是某个特定的类型\n\n### 使用 `Box` 将数据存储在堆上\n\n如果一个变量拥有一个数值 `let a = 3`，那变量 `a` 必然是存储在栈上的，那如果我们想要 `a` 的值存储在堆上就需要使用 `Box<T>`：\n\n```rust\nfn main() {\n    let a = Box::new(3);\n    println!(\"a = {}\", a); // a = 3\n\n    // 下面一行代码将报错\n    // let b = a + 1; // cannot add `{integer}` to `Box<{integer}>`\n}\n```\n\n这样就可以创建一个智能指针指向了存储在堆上的 `3`，并且 `a` 持有了该指针。在本章的引言中，我们提到了智能指针往往都实现了 `Deref` 和 `Drop` 特征，因此：\n\n- `println!` 可以正常打印出 `a` 的值，是因为它隐式地调用了 `Deref` 对智能指针 `a` 进行了解引用\n- 最后一行代码 `let b = a + 1` 报错，是因为在表达式中，我们无法自动隐式地执行 `Deref` 解引用操作，你需要使用 `*` 操作符 `let b = *a + 1`，来显式的进行解引用\n- `a` 持有的智能指针将在作用域结束（`main` 函数结束）时，被释放掉，这是因为 `Box<T>` 实现了 `Drop` 特征\n\n## `Rc<T>`\n\n引用计数(reference counting)，顾名思义，通过记录一个数据被引用的次数来确定该数据是否正在被使用。当引用次数归零时，就代表该数据不再被使用，因此可以被清理释放。\n\n而 `Rc` 正是引用计数的英文缩写。当我们**希望在堆上分配一个对象供程序的多个部分使用且无法确定哪个部分最后一个结束时，就可以使用 `Rc` 成为数据值的所有者**，例如之前提到的多线程场景就非常适合。\n',
    tag: 'Programming',
    time: 'November 12, 2023',
  };

  return (
    <PostContainer>
      <PostDetail
        title={post.title}
        id={post.id}
        content={post.content}
        time={post.time}
        tag={post.tag} />
      <PostComment />
    </PostContainer>
  );
};

export default Post;
